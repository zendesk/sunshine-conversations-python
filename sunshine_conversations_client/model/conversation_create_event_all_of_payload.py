# coding: utf-8

"""
    Sunshine Conversations API

    The version of the OpenAPI document: 17.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from sunshine_conversations_client.model.conversation_truncated import ConversationTruncated
from sunshine_conversations_client.model.referral import Referral
from sunshine_conversations_client.model.source_with_campaign_webhook import SourceWithCampaignWebhook
from sunshine_conversations_client.model.user import User
from typing import Optional, Set
from typing_extensions import Self

class ConversationCreateEventAllOfPayload(BaseModel):
    """
    The payload of the event. The contents of this object depend on the type of event.
    """ # noqa: E501
    conversation: Optional[ConversationTruncated] = Field(default=None, description="The conversation that was created.")
    creation_reason: Optional[StrictStr] = Field(default=None, description="The reason why the conversation was created, if applicable. * `linkRequest` - The conversation was created in order to generate a link request to transfer the user to a different channel. * `message` - The conversation was created because a message was sent. * `none` - The conversation was not created for a specific purpose. Used primarily when a conversation is created via the Create Conversation API. * `notification` - The conversation was created by a call to the Notification API. * `prechatCapture` - The conversation was created because the user completed a prechat capture form in the Web Messenger. * `startConversation` - The conversation was created because of a call to the startConversation API on one of the SDK integrations, or a start conversation event was triggered from a messaging channel. * `proactiveMessaging` - The conversation was created because the user interacted with a campaign. ", alias="creationReason")
    source: Optional[SourceWithCampaignWebhook] = Field(default=None, description="The source of the creation.")
    user: Optional[User] = Field(default=None, description="The user associated with the conversation. Only present if the created conversation was of type personal. For sdkGroup conversations, the list of participants can be fetched using the List Participants API, if required.")
    referral: Optional[Referral] = Field(default=None, description="Referral information, if applicable.")
    __properties: ClassVar[List[str]] = ["conversation", "creationReason", "source", "user", "referral"]

    @field_validator('creation_reason')
    def creation_reason_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['linkRequest', 'message', 'none', 'notification', 'prechatCapture', 'startConversation', 'proactiveMessaging']):
            raise ValueError("must be one of enum values ('linkRequest', 'message', 'none', 'notification', 'prechatCapture', 'startConversation', 'proactiveMessaging')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of ConversationCreateEventAllOfPayload from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of conversation
        if self.conversation:
            _dict['conversation'] = self.conversation.to_dict()
        # override the default output from pydantic by calling `to_dict()` of source
        if self.source:
            _dict['source'] = self.source.to_dict()
        # override the default output from pydantic by calling `to_dict()` of user
        if self.user:
            _dict['user'] = self.user.to_dict()
        # override the default output from pydantic by calling `to_dict()` of referral
        if self.referral:
            _dict['referral'] = self.referral.to_dict()
        # set to None if user (nullable) is None
        # and model_fields_set contains the field
        if self.user is None and "user" in self.model_fields_set:
            _dict['user'] = None

        # set to None if referral (nullable) is None
        # and model_fields_set contains the field
        if self.referral is None and "referral" in self.model_fields_set:
            _dict['referral'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of ConversationCreateEventAllOfPayload from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "conversation": ConversationTruncated.from_dict(obj["conversation"]) if obj.get("conversation") is not None else None,
            "creationReason": obj.get("creationReason"),
            "source": SourceWithCampaignWebhook.from_dict(obj["source"]) if obj.get("source") is not None else None,
            "user": User.from_dict(obj["user"]) if obj.get("user") is not None else None,
            "referral": Referral.from_dict(obj["referral"]) if obj.get("referral") is not None else None
        })
        return _obj


