# coding: utf-8

"""
    Sunshine Conversations API

    The version of the OpenAPI document: 17.0.0
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501

from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from sunshine_conversations_client.model.user_merge_event_all_of_payload_merged_clients import UserMergeEventAllOfPayloadMergedClients
from sunshine_conversations_client.model.user_merge_event_all_of_payload_merged_conversations import UserMergeEventAllOfPayloadMergedConversations
from sunshine_conversations_client.model.user_merge_event_all_of_payload_merged_users import UserMergeEventAllOfPayloadMergedUsers
from typing import Optional, Set
from typing_extensions import Self

class UserMergeEventAllOfPayload(BaseModel):
    """
    The payload of the event. The contents of this object depend on the type of event.
    """ # noqa: E501
    merged_users: Optional[UserMergeEventAllOfPayloadMergedUsers] = Field(default=None, alias="mergedUsers")
    merged_conversations: Optional[UserMergeEventAllOfPayloadMergedConversations] = Field(default=None, alias="mergedConversations")
    merged_clients: Optional[UserMergeEventAllOfPayloadMergedClients] = Field(default=None, alias="mergedClients")
    discarded_metadata: Optional[Dict[str, Any]] = Field(default=None, description="A flat object with the set of metadata properties that were discarded when merging the two users. This should contain values only if the combined metadata fields exceed the 4KB limit.", alias="discardedMetadata")
    reason: Optional[StrictStr] = Field(default=None, description="The reason for which the users merged. * `api` - The users were merged using the API. * `channelLinking` - The users were merged as a result of initiating a channel link. * `sdkLogin` - The users were merged as a result of logging into an SDK device. ")
    __properties: ClassVar[List[str]] = ["mergedUsers", "mergedConversations", "mergedClients", "discardedMetadata", "reason"]

    @field_validator('reason')
    def reason_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['api', 'channelLinking', 'sdkLogin']):
            raise ValueError("must be one of enum values ('api', 'channelLinking', 'sdkLogin')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of UserMergeEventAllOfPayload from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of merged_users
        if self.merged_users:
            _dict['mergedUsers'] = self.merged_users.to_dict()
        # override the default output from pydantic by calling `to_dict()` of merged_conversations
        if self.merged_conversations:
            _dict['mergedConversations'] = self.merged_conversations.to_dict()
        # override the default output from pydantic by calling `to_dict()` of merged_clients
        if self.merged_clients:
            _dict['mergedClients'] = self.merged_clients.to_dict()
        # set to None if merged_conversations (nullable) is None
        # and model_fields_set contains the field
        if self.merged_conversations is None and "merged_conversations" in self.model_fields_set:
            _dict['mergedConversations'] = None

        # set to None if merged_clients (nullable) is None
        # and model_fields_set contains the field
        if self.merged_clients is None and "merged_clients" in self.model_fields_set:
            _dict['mergedClients'] = None

        # set to None if discarded_metadata (nullable) is None
        # and model_fields_set contains the field
        if self.discarded_metadata is None and "discarded_metadata" in self.model_fields_set:
            _dict['discardedMetadata'] = None

        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of UserMergeEventAllOfPayload from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "mergedUsers": UserMergeEventAllOfPayloadMergedUsers.from_dict(obj["mergedUsers"]) if obj.get("mergedUsers") is not None else None,
            "mergedConversations": UserMergeEventAllOfPayloadMergedConversations.from_dict(obj["mergedConversations"]) if obj.get("mergedConversations") is not None else None,
            "mergedClients": UserMergeEventAllOfPayloadMergedClients.from_dict(obj["mergedClients"]) if obj.get("mergedClients") is not None else None,
            "discardedMetadata": obj.get("discardedMetadata"),
            "reason": obj.get("reason")
        })
        return _obj


